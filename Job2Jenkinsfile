/*
* El siguiente JenkinsFile se corresponde al Job 2 Correspondiente a la Recoleccion de APIs
* de la solución MMPORTAL
*/
class PublishChanges {
        /*
    *   La clase PublishChanges se encarga de las siguientes tareas:
    *   - Comprobar si para una serie de rutas, estas contienen un markdown valido (Markdown situado dentro de la carpeta publish)
    *   - Almacenar dichas rutas para una comprobación posterior.
    */
	private def validExtensions = ["md"] // Array que contiene las extensiones validas para las rutas
    private int NumberMDsAffected; // Contador del numero de Makrdowns afectadas en la ejecucion del Job
    private boolean MDChanged = false /*
                                        * true -> Indica que hay Markdowns modificados en este Job
                                        * false -> (Por defecto), indica que en el job actual no existen Markdowns modificadas o anadidas
    */ 
    def MDsRoutes = []; // Array de String que almacenará las rutas modificadas o anadidas
    
    def getNumberMDsAffected() {
         /*
        * Devuelve el número de Markdowns afectados
        */
        return NumberMDsAffected;
    }
    
    def checkIsMD(route){
         /*
        *   Input : route -> String con la ruta a comprobar, si es una ruta de Markdown valida
        *   Output: isRouteMD-> Booleano
        *                   true -> Indica que la ruta actual es un Markdown.
        *                   false -> Indica que la ruta actual no es un Markdown.
        *   Descripcion: Este metodo se encarga de comprobar si una ruta es un Markdown valido.
        *   En primer lugar se obtiene la extension del fichero, si la extension está en el array de extensiones validas
        *   se comprueba con una expresión regular si la ruta se encuentra dentro de la carpeta "PUBLISH" en caso afirmativo se considera una
        *   ruta de Markdown.
        */
        boolean isRouteMD = false;
		String extension = route.tokenize(".")[-1];
		if(extension in validExtensions) {
			if(route =~/PUBLISH\/(.*)/){
			    isRouteMD = true;    
			}
		}
        return isRouteMD;
    }
    
    def computeMDChanged() {
       /*
        *   Descripcion: Este metodo interno actualiza el booleano MDChanged, mediante la comprobación del numero actual de Markdowns almacenados
        *   Si este numero es mayor que cero el booleano MDChanged cambia su valor a true, en caso contrario se pone a false.
        *
        */
        int total_size_changes = this.getNumberMDsAffected()
	    if( total_size_changes > 0)
	    {
	        this.MDChanged = true
        } else {
            this.MDChanged = false
        }
    }
    def setMDsRoutes(arrayCommits) {
        /*
        *   Input : arrayCommits -> Array con las rutas de cada uno de los commits afectados.
        *   
        *   Descripcion: Este metodo itera sobre cada una de las rutas, y tras comprobar si es un Markdown, le añade al array MDsRoutes, 
        *   si y solo si esa ruta no estaba añadida antes.
        *   Tras acabar, se setea el valor de NumberMDsAffected a partir del tamano actual de MDsRoutes
        *   y se llama a computeMDChanged()  para actualizar el valor del booleano MDChanged.
        *
        */
        for(String route in arrayCommits){
			if(checkIsMD(route)) {
			 def alreadyExists = route in MDsRoutes
              if(!alreadyExists){
				MDsRoutes.add(route)
              }
			}
        }
        NumberMDsAffected = MDsRoutes.size();    
        this.computeMDChanged()
    }
    
    def getMDsRoutes() {
                /*
        * Devuelve una copia del array MDsRoutes que contiene las rutas de los Markdown
        */
        return MDsRoutes
    }
    
    def getMDsRoutesToString() {
        /*
        *   Output: routes -> String unico, que contiene las rutas de cada uno de los Markdowns concatenados y separados por una nueva linea
        *   Descripcion: Este metodo recorre el array MDsRoutes y devuelve las rutas en ese array en un unico string separadas por nueva linea
        *   El motivo de este metodo es que es necesaria esta representacion de las rutas para trabajar con ellas a nivel de script BASH.
        */
        //Returns the routes in the following format route1, route2,
        String routes = ""
        int routeSize = MDsRoutes.size()
        for(int i=0; i<routeSize;i++) {
            String storedRoute = MDsRoutes[i]
            if(i==routeSize-1){
             routes += storedRoute   
            } else {
                routes += storedRoute+"\n"
            }
            
        }
        
        return routes
    }

    def isMDChanged() {
    // Devuelve MDChanged, si existe al menos un Markdown en este job el valor de este booleano sera true.
        return MDChanged
    }
    
}

def compute_MD_affected(current_commit)
{
    /*
    *   Input: current_commit -> JSON que se corresponde al head_commit o commit de cabecera, valor correspondiente al payload enviado 
    *                           desde el commit de cabecera. 
    *   Output: innerMDChanges -> Objeto del tipo PublishChanges y creado en este metodo, con los valores del commit de cabecera ya incluidos.
    *   Descripcion: Esta funcion( no metodo dado que no pertenece a ninguna clase)
    *    crea el objeto PublishChanges que se usará a lo largo del Job, y lo inicializa con los valores del commit de cabecera, en concreto:
    *       - Envia al objeto PublishChanges el id del commit de cabecera.
    *       - Envia al objeto PublishChanges las rutas de los ficheros anadidos en el commit actual.
    *       - Envia al objeto PublishChanges las rutas de los ficheros modificados en el commit actual.
    */
    def added_files = current_commit.added
	def modified_files = current_commit.modified
	PublishChanges innerMDChanges = new PublishChanges();
	innerMDChanges.setMDsRoutes(added_files);
	innerMDChanges.setMDsRoutes(modified_files);
	return  innerMDChanges
}


PublishChanges myPublishChanges = new PublishChanges() // Se crea el objeto myPublishChanges fuera de la directiva de pipeline, con el objetivo de tener acceso al objeto desde todas las fases.
def hugoVersionToUse = "latest"
pipeline {
    agent any // Se utilizará para la mayoria de steps un agente any.
    environment{
        /* Las variables de environment recogidas aqui, son variables de SOLO LECTURA, cuyo acceso es posible desde cada una de las fases.
        * Es posible no obstante con el valor withEnv modificar PARA una fase en concreto el valor de alguna de las variables aqui presentadas 
        */
        ROUTE_LIST = myPublishChanges.getMDsRoutesToString() // Tiene la lista actual de rutas en formato String
        REPOSITORY = 'https://github.com/masmovil/developer-portal' // Direccion del repositorio
        REPOSITORY_GIT = 'github.com/masmovil/developer-portal.git' // Direccion de subida del repositorio
        CREDENTIALS = 'developer-portal'// Credenciales del repositorio
        BRANCH = 'master' // Rama principal del trabajo

        registryCredential = "gcr:mm-cloudbuild"  // Credenciales del repositorio de Docker donde se alojará la imagen de NGINX
        registry = "gcr.io/mm-cloudbuild/masmovilportal" // Direccion del repositorio de Docker donde se alojará la imagen de NGINX
                       
        //hugoVersion = "latest";

        KUBERNETES_SERVICE_NAME = 'developer-portal'
        REGEX_STAGING = '^v[0-9]+(\\.[0-9]+)*-rc(\\.([0-9])+)?$'
        REGEX_PROD = '^v[0-9]+(\\.[0-9]+)*$'

    }




    stages {


        stage('Webhook Called'){
            steps {
                script 
                {   
                      /* 
                    Descripcion: En esta fase se realizan las siguientes acciones:
                    1. Se lee en primer lugar el payload enviado desde el hook y recogido en la variable env.payload.
                    2. Se almacena el commit de cabecera y se crea el objeto PublishChanges con estos valores (modificando el objeto myPublishChanges)
                    3. Si no existe información de rutas en myPublishChanges se imprime un mensaje indicando que no existen rutas afectadas en la ejecución de este Job.
                    */
                    def payload = readJSON text: env.payload
                    def head_commit = payload.head_commit
                    myPublishChanges =compute_MD_affected(head_commit)
                    
                    if(!myPublishChanges.isMDChanged()) {
                        echo "There are no Markdowns to be published in this commit "
                    }
                }
	        }
        }
        
        stage('Initialize Repository Configuration') {
            steps {
                script {
                    /* 
                    Descripcion: En esta fase se realizan las siguientes acciones:
                    ---- Script Bash
                    1. Se inicializa el repositorio, y se obtiene la lista de commits de la rama master
                    1.1 Si no existe el fichero current_commit, se toma como ultimo commit comprobado el anotado por la variable de git HEAD.
                    1.2 Si existe el fichero current_commit se toma como ultimo commit comprobado el que viene en ese fichero.
                    1.3 Se obtienen los identificadores de los commits restantes comprendidos entre el ultimo de la rama master y el ultimo comprobado.
                        El resultado se guarda en un fichero (missing_commits_file)
                    1.4 Sobre el fichero obtenido en el paso anterior, se obtienen las rutas que afectaban a dicho commit, y se guardan en el fichero missing_changes_file
                    1.5 Se almacena el commit ultimo comprobado en el fichero current_commit.
                    -----
                    2.1 Se comprueba si en el paso anterio se ha creado el fichero missing_changes_file, si es asi se lee, almacenandolo en la variable missing_commits
                    2.2 Si existia el fichero, se añade la informacion de las rutas al objeto myPublishChanges.
                    ----SI Y SOLO SI existen Markdown publicadas
                    3. Se inicia el repositorio de Git en la rama master con las credenciales proporcionadas.
                    */
                    withCredentials([usernamePassword(credentialsId: '806bdc4e-af90-4255-83fc-b434c30a6720', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
                    sh '''#!/bin/bash
    		            touch missing_changes_file
    		            echo "https://${USERNAME}:${PASSWORD}@$REPOSITORY_GIT"
    		            git remote set-url origin "https://${USERNAME}:${PASSWORD}@$REPOSITORY_GIT"
    		            current_commit=$(git rev-parse HEAD)
    		            echo $current_commit
    		            git fetch origin $BRANCH
    		            git rev-list $current_commit..FETCH_HEAD > missing_commits_file
    		            cat missing_commits_file | while read line; do
    		                echo "COMMIT : "+$line
    		                echo "------"
    		                git diff-tree --no-commit-id --name-only -r $line >> missing_changes_file
    		            done
    		            
                    '''
                    }
                    // Turn the file into a valid array
                    def missing_commits = readFile(file: 'missing_changes_file').split('\n')
                    if(missing_commits.length > 0 ){
                        if(missing_commits[0] != ""){
                            myPublishChanges.setMDsRoutes(missing_commits)
                        }
                    }
                    // Si y solo si hay markdowns por publicar, se inicia el repositorio
                    if(myPublishChanges.isMDChanged()){
                        git url: REPOSITORY,
                        credentialsId: CREDENTIALS,
                        branch: BRANCH 
                    }
                }
            }
        }
        
        stage('GET version of HUGO to use') {
            steps {
                script {
                    /**
                    Descripcion: En esta fase se realizan las siguientes acciones:
                    Si existe el archivo hugo/generate_new_hugo_version, se obtiene su contenido como nombre de versión y se carga la rama master del repositorio.
                    Si no existe el archivo hugo/generate_new_hugo_version, se marca una variable para saltar el resto de pasos.
                    */
                    env.WORKSPACE = pwd()
                    echo "env.WORKSPACE " + env.WORKSPACE
                    echo "home ${HOME}"
                    echo "home ${env.HOME}"

                    def thereAreAVersionToUse = fileExists "${env.WORKSPACE}/hugo/version_to_use"
                    echo "isNeededToCreateANewHugoVersion " + thereAreAVersionToUse

                    if(thereAreAVersionToUse){                            
                        version = readFile "${env.WORKSPACE}/hugo/version_to_use"
                        echo "version " + version
                        env.hugoVersionToUse = version
                    
                        git url: REPOSITORY,
                        credentialsId: CREDENTIALS,
                        branch: BRANCH 
                    } else {
                        env.hugoVersionToUse = "latest"
                    }
                }
            }
        }
    
        stage('HUGO - Transformation into HTML') {
            /*
            *   Descripcion:
            *   En este step, se utiliza como agente la imagen de HUGO, para evitar que se ejecute en una maquina o directorio
            *   diferente al resto del Job se usa la funcion reuseNode true
            * -- Si y solo si existen markdown publicados
            * ----- Script BASH ----
            *   1. Se crea la carpeta temporal workspace
            *   2. Se almacena en olddir el directorio actual de trabajo
            *   3. Se copia el contenido completo de PUBLISH a la carpeta en raiz /hugo/content/
            *   3.1 Se cambia el directorio activo a /hugo
            *   4. Se ejecuta hugo que transforma toda la carpeta content en HTML, y los deposita en workspace
            *   4.1 Se cambia al directorio activo anterior (olddir)
            *   4.2 Se copia el resultado generado en /hugo/workspace a la carpeta creada en el punto 1.
            *   4.3 Aseguramos los permisos con chmod -R de workspace
            *   TODO: Existe una variable que Jenkins proporciona de forma automatica que representa lo mismo que olddir.
                 Sustituir todas las apariciones de olddir con la variable anterior.
            */
            agent {
                docker { 
                    image 'eu.gcr.io/mm-cloudbuild/hugo:' + env.hugoVersionToUse
                    registryUrl "https://eu.gcr.io"
                    registryCredentialsId "gcr:mm-cloudbuild"
                    args '-u root'
                    reuseNode true
                }
            }
            steps {
                echo 'Calling HUGO docker image to transform the published Markdown into HTML'
                script {
                    if(myPublishChanges.isMDChanged()){
                    sh '''#!/bin/bash
                        mkdir workspace/
                        olddir=$(pwd)
                        echo $olddir
                        #ls PUBLISH
                        #cp -r hugo/* /hugo
                        
                        #copy content
                        cp -r PUBLISH/* /hugo/content/
                        cp -r images/* /hugo/static/

                        ls /hugo/content/en/docs
                        cd /hugo
                        hugo -d workspace/
                        cd "$olddir"
                        cp -r /hugo/workspace/* workspace/

                        echo 1
                        ls /hugo/workspace/
                        echo 2
                        ls workspace/

                        chmod -R 777 workspace
                        '''
                    }
                }   
            }
        }
                    
        stage('Push HTML to web server') {
            steps {
                script {
                /*
                *   Descripcion:
                * -- Si y solo si existen markdown publicados
                *   1. Se crea usando el plugin de docker, una imagen con el siguiente nombre:
                *   "eu.gcr.io/mm-cloudbuild/masmovilportal:latest"
                *   2. Se usa el modificador withDockerRegistry, que permite realizar inyeccion de credenciales
                *   2.1 Se realiza push de la imagen contra el repositorio docker proporcionado.
                */
                    if( myPublishChanges.isMDChanged()) {
                        echo 'Creating Nginx image'
                        
                        //registry = "gcr.io/mm-cloudbuild/masmovilportal" // Direccion del repositorio de Docker donde se alojará la imagen de NGINX
                        dockerImage = docker.build registry + ":latest"
                        withDockerRegistry([credentialsId: 'gcr:mm-cloudbuild', url: 'https://eu.gcr.io']) {
                            dockerImage.push()
                        }
                        
        
                        //develpment code
                        registry = "dmarciel/hugo"
                        dockerImage = docker.build registry + ":latest"
                        withDockerRegistry([credentialsId: 'development-docker']) {
                            dockerImage.push()
                        }

                    }
                }
            }
        }

        stage('Clear the workspace') {
            steps {
                script {
                    if( myPublishChanges.isMDChanged()) {
                        /*
                        *   Descripcion:
                        * -- Si y solo si existen markdown publicados
                        * --- Script BASH
                        *   1.Si existe el fichero missing_commits_file se borra
                        *   2.Si existe el fichero missing_changes_file se borra
                        *   3.Se borra la carpeta files y workspace
                        *   TODO: La carpeta files no deberia existir en este job.
                        *   4. Se borra la imagen creada debido a que ya ha sido pusheada.
                        */
                        sh '''#!/bin/bash
                        if [[ -f missing_commits_file ]]; then
                            rm missing_commits_file
                        fi
                        if [[ -f missing_changes_file ]]; then
                            rm missing_changes_file
                        fi
                        rm -rf files workspace
                        docker rmi $registry:latest
                        '''
                    }
                }
            }
        }
        
    }
}
